#!/usr/bin/env bash
#
# [Release]: SnoopGod 24.04.2 LTS amd64
# [Website]: https://snoopgod.com/releases/?ver=24.04.2
# [License]: http://www.gnu.org/licenses/gpl-3.0.html

## ---------------- ##
## DEFINE VARIABLES ##
## ---------------- ##

## Colour Output
## -------------
texterror="\033[01;31m"     # Text Error
textvalid="\033[01;32m"     # Text Success
textalert="\033[01;33m"     # Text Warnings/Information
textlabel="\033[01;34m"     # Text Heading
textreset="\033[00m"        # Text Reset

## Path Backup Directory
## ----------------------
torbridgepath="/etc/torbridge"

## Packaging
## ---------
package="TorBridge"
version="v2.0.5"
website="neoslab.com"

## Tor Exclude CIDR
## ----------------
tor_cidr="192.168.0.0/16 172.16.0.0/12 10.0.0.0/8"

## Tor UUID
## --------
tor_uuid="debian-tor"

## Tor Port
## --------
tor_port="9040"

## Tor DNS
## -------
tor_dns="9053"

## ---------------- ##
## DEFINE FUNCTIONS ##
## ---------------- ##

## Load Status
## -----------
function loadstatus()
{
    texterror=$(tput setaf 1)
    textvalid=$(tput setaf 2)
    textalert=$(tput setaf 3)
    textlabel=$(tput setaf 4)
    textreset=$(tput sgr0)

    message=$1
    display="[$2]"

    if [ "$3" == "issue" ];
    then
        return="$texterror${display}$textreset"
    elif [ "$3" == "valid" ];
    then
        return="$textvalid${display}$textreset"
    elif [ "$3" == "warning" ];
    then
        return="$textalert${display}$textreset"
    elif [ "$3" == "info" ];
    then
        return="$textalert${display}$textreset"
    else
        return="$textreset${display}$textreset"
    fi

    let COL=$(tput cols)-${#message}+${#return}-${#display}

    echo -n $message
    printf "%${COL}s\n"  "$return"
}

## Create Backup Directory
## -----------------------
function backupdir()
{
    if [ ! -d "$torbridgepath" ];
    then
        mkdir -p "$torbridgepath"
    fi
}

## Backup TorRC
## ------------
function backuptorrc()
{
    mv /etc/tor/torrc $torbridgepath/torrc.bak
    loadstatus "[+] Backed-up TorRC" "OK" "valid"
}

## Backup Resolv
## -------------
function backupresolv()
{
    mv /etc/resolv.conf $torbridgepath/resolv.conf.bak
    loadstatus "[+] Backed-up Resolv" "OK" "valid"
}

## Backup Iptables
## ---------------
function backupiptables()
{
    iptables-save > $torbridgepath/iptables.rules.bak
    loadstatus "[+] Backed-up Iptables" "OK" "valid"
}

## Backup Sysctl
## -------------
function backupsysctl()
{
    sysctl -a > $torbridgepath/sysctl.conf.bak
    loadstatus "[+] Backed-up Sysctl" "OK" "valid"
}

## Change MAC Address
## ------------------
function changemac()
{
    interfaces=$(ip -o link show | awk -F': ' '{print $2}')
    for interface in $interfaces;
    do
        if [ $interface != "lo" ];
        then
            ip link set $interface down &>"/dev/null"
            macchanger -r $interface &>"/dev/null"
            ip link set $interface up &>"/dev/null"
        fi
    done
    loadstatus "[+] Changed MAC address" "OK" "valid"
}

## Check Internet status
## ---------------------
function checkinternet()
{
    for i in {1..10};
    do
        ping -c 1 -W ${i} www.google.com &>/dev/null && break;
    done

    if [[ "$?" -ne 0 ]];
    then
        echo
        echo -e "${texterror}[!]${textreset} An unknown error occured ~ Possible DNS issues or no Internet connection"
        echo -e "${texterror}[!]${textreset} Quitting ..."
        echo
        exit 1
    fi
}

## Check Root
## ----------
function checkroot()
{
    if [ $(id -u) -ne 0 ];
    then
        echo
        echo -e "[!] This script must be run as root"
        echo -e "[!] Quitting ..."
        echo
        exit 1
    fi
}

## Check if Tor Started
## --------------------
function checkstatus()
{
    if [ -e "$torbridgepath/started" ];
    then
        return 0
    else
        return 1
    fi
}

## Build Resolv Config
## -------------------
function configresolv()
{
    echo '# Generated by TorBridge' | tee /etc/resolv.conf >/dev/null 2>&1
    echo 'nameserver 127.0.0.1' | sudo tee -a /etc/resolv.conf >/dev/null 2>&1
    echo 'nameserver 1.1.1.1' | sudo tee -a /etc/resolv.conf >/dev/null 2>&1
    echo 'nameserver 1.0.0.1' | sudo tee -a /etc/resolv.conf >/dev/null 2>&1
    echo 'nameserver 208.67.222.222' | sudo tee -a /etc/resolv.conf >/dev/null 2>&1
    echo 'nameserver 208.67.220.220' | sudo tee -a /etc/resolv.conf >/dev/null 2>&1
    echo 'nameserver 8.8.8.8' | sudo tee -a /etc/resolv.conf >/dev/null 2>&1
    echo 'nameserver 8.8.4.4' | sudo tee -a /etc/resolv.conf >/dev/null 2>&1
    chmod 644 /etc/resolv.conf
    loadstatus "[+] Nameservers configured" "OK" "valid"
}

## Build TorRC Config
## ------------------
function configtorrc()
{
    echo '# Generated by TorBridge' | tee /etc/tor/torrc >/dev/null 2>&1
    echo 'DataDirectory /var/lib/tor' | tee -a /etc/tor/torrc >/dev/null 2>&1
    echo 'VirtualAddrNetwork 10.192.0.0/10' | tee -a /etc/tor/torrc >/dev/null 2>&1
    echo 'AutomapHostsOnResolve 1' | tee -a /etc/tor/torrc >/dev/null 2>&1
    echo 'AutomapHostsSuffixes .exit,.onion' | tee -a /etc/tor/torrc >/dev/null 2>&1
    echo 'TransPort 127.0.0.1:'${tor_port}' IsolateClientAddr IsolateSOCKSAuth IsolateClientProtocol IsolateDestPort IsolateDestAddr' | tee -a /etc/tor/torrc >/dev/null 2>&1
    echo 'SocksPort 127.0.0.1:9050 IsolateClientAddr IsolateSOCKSAuth IsolateClientProtocol IsolateDestPort IsolateDestAddr' | tee -a /etc/tor/torrc >/dev/null 2>&1
    echo 'ControlPort 9051' | tee -a /etc/tor/torrc >/dev/null 2>&1
    echo 'HashedControlPassword 16:FDE8ED505C45C8BA602385E2CA5B3250ED00AC0920FEC1230813A1F86F' | tee -a /etc/tor/torrc >/dev/null 2>&1
    echo 'DNSPort 127.0.0.1:'${tor_dns} | tee -a /etc/tor/torrc >/dev/null 2>&1
    echo 'HardwareAccel 1' | tee -a /etc/tor/torrc >/dev/null 2>&1
    echo 'TestSocks 1' | tee -a /etc/tor/torrc >/dev/null 2>&1
    echo 'AllowNonRFC953Hostnames 0' | tee -a /etc/tor/torrc >/dev/null 2>&1
    echo 'WarnPlaintextPorts 23,109,110,143,80' | tee -a /etc/tor/torrc >/dev/null 2>&1
    echo 'ClientRejectInternalAddresses 1' | tee -a /etc/tor/torrc >/dev/null 2>&1
    echo 'NewCircuitPeriod 40' | tee -a /etc/tor/torrc >/dev/null 2>&1
    echo 'MaxCircuitDirtiness 600' | tee -a /etc/tor/torrc >/dev/null 2>&1
    echo 'MaxClientCircuitsPending 48' | tee -a /etc/tor/torrc >/dev/null 2>&1
    echo 'UseEntryGuards 1' | tee -a /etc/tor/torrc >/dev/null 2>&1
    echo 'EnforceDistinctSubnets 1' | tee -a /etc/tor/torrc >/dev/null 2>&1
    chmod 644 /etc/tor/torrc
    loadstatus "[+] Tor Network configured" "OK" "valid"
}

## Flush Iptables Rules
## --------------------
function flushiptables()
{
    iptables -F
    iptables -t nat -F
}

## Revert Torrc
## ------------
function reverttorrc()
{
    if [ -e $torbridgepath/torrc.bak ];
    then
        rm -f /etc/tor/torrc
        mv $torbridgepath/torrc.bak /etc/tor/torrc
        loadstatus "[+] Restored TorRC" "OK" "valid"
    fi
}

## Revert Resolv
## -------------
function revertresolv()
{
    if [ -e $torbridgepath/resolv.conf.bak ];
    then
        rm -f $torbridgepath/resolv.conf
        mv $torbridgepath/resolv.conf.bak /etc/resolv.conf
        loadstatus "[+] Restored Resolv" "OK" "valid"
    fi
}

## Revert Iptables
## ---------------
function revertiptables()
{
    if [ -e $torbridgepath/iptables.rules.bak ];
    then
        iptables-restore < $torbridgepath/iptables.rules.bak
        rm -f $torbridgepath/iptables.rules.bak
        loadstatus "[+] Restored Iptables" "OK" "valid"
    fi
}

## Revert MAC Address
## ------------------
function revertmac()
{
    interfaces=$(ip -o link show | awk -F': ' '{print $2}')
    for interface in $interfaces;
    do
        if [ $interface != "lo" ];
        then
            ip link set $interface down &>"/dev/null"
            macchanger -p $interface &>"/dev/null"
            ip link set $interface up &>"/dev/null"
        fi
    done
    loadstatus "[+] Reverted MAC address" "OK" "valid"
}

## Revert Sysctl
## -------------
function revertsysctl()
{
    if [ -e $torbridgepath/sysctl.conf.bak ];
    then
        sysctl -p $torbridgepath/sysctl.conf.bak &>"/dev/null"
        rm -f $torbridgepath/sysctl.conf.bak
        loadstatus "[+] Restored Sysctl" "OK" "valid"
    fi
}

## Rules Iptables
## --------------
function rulesiptables()
{
    ## Set Iptables Nat
    ## ----------------
    iptables -t nat -A OUTPUT -m owner --uid-owner $tor_uuid -j RETURN

    ## Set DNS Redirect
    ## ----------------
    iptables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-ports $tor_dns
    iptables -t nat -A OUTPUT -p tcp --dport 53 -j REDIRECT --to-ports $tor_dns
    iptables -t nat -A OUTPUT -p udp -m owner --uid-owner $tor_uuid -m udp --dport 53 -j REDIRECT --to-ports $tor_dns

    ## Resolve domains mapping 10.192.0.0/10 address space
    ## ---------------------------------------------------
    iptables -t nat -A OUTPUT -p tcp -d 10.192.0.0/10 -j REDIRECT --to-ports $tor_port
    iptables -t nat -A OUTPUT -p udp -d 10.192.0.0/10 -j REDIRECT --to-ports $tor_port

    ## Exclude Tor CIDR
    ## ----------------
    for NET in $tor_cidr 127.0.0.0/9 127.128.0.0/10;
    do
        iptables -t nat -A OUTPUT -d $NET -j RETURN
        iptables -A OUTPUT -d "$NET" -j ACCEPT
    done

    ## Redirect all other output through Tor
    ## -------------------------------------
    iptables -t nat -A OUTPUT -p tcp --syn -j REDIRECT --to-ports $tor_port
    iptables -t nat -A OUTPUT -p udp -j REDIRECT --to-ports $tor_port
    iptables -t nat -A OUTPUT -p icmp -j REDIRECT --to-ports $tor_port

    ## Accept already established connections
    ## --------------------------------------
    iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

    ## Allow only Tor output
    ## ---------------------
    iptables -A OUTPUT -m owner --uid-owner $tor_uuid -j ACCEPT
    iptables -A OUTPUT -j REJECT

    loadstatus "[+] Applied Iptables rules" "OK" "valid"
}

## Rules Sysctl 
## ------------
function rulessysctl()
{
    ## Swappiness
    ## ----------
    sysctl -w vm.dirty_ratio=10 &>"/dev/null"
    sysctl -w vm.dirty_background_ratio=5 &>"/dev/null"
    sysctl -w vm.dirty_expire_centisecs=2000 &>"/dev/null"
    sysctl -w vm.dirty_writeback_centisecs=1000 &>"/dev/null"
    sysctl -w vm.swappiness=10 &>"/dev/null"
    sysctl -w vm.vfs_cache_pressure=70 &>"/dev/null"

    ## Disable Explicit Congestion Notification in TCP
    ## -----------------------------------------------
    sysctl -w net.ipv4.tcp_ecn=0 &>"/dev/null"

    ## Window scaling
    ## --------------
    sysctl -w net.ipv4.tcp_window_scaling=1 &>"/dev/null"

    ## Increase Linux auto-tuning TCP buffer limits
    ## --------------------------------------------
    sysctl -w net.ipv4.tcp_rmem="8192 87380 16777216" &>"/dev/null"
    sysctl -w net.ipv4.tcp_wmem="8192 65536 16777216" &>"/dev/null"

    ## Increase TCP max buffer size
    ## ----------------------------
    sysctl -w net.core.rmem_max=16777216 &>"/dev/null"
    sysctl -w net.core.wmem_max=16777216 &>"/dev/null"

    ## Increase number of incoming connections backlog
    ## -----------------------------------------------
    sysctl -w net.core.netdev_max_backlog=16384 &>"/dev/null"
    sysctl -w net.core.dev_weight=64 &>"/dev/null"

    ## Increase number of incoming connections
    ## ---------------------------------------
    sysctl -w net.core.somaxconn=32768 &>"/dev/null"

    ## Increase the maximum amount of option memory buffers
    ## ----------------------------------------------------
    sysctl -w net.core.optmem_max=65535 &>"/dev/null"

    ## Increase the TCP-time-wait buckets
    ## Pool sizeto prevent simple DOS attacks
    ## --------------------------------------
    sysctl -w net.ipv4.tcp_max_tw_buckets=1440000 &>"/dev/null"

    ## Try to reuse time-wait connections
    ## ----------------------------------
    sysctl -w net.ipv4.tcp_tw_reuse=1 &>"/dev/null"

    ## Limit number of allowed orphans
    ## Each orphan can eat up to 16M of unswappable memory
    ## ---------------------------------------------------
    sysctl -w net.ipv4.tcp_max_orphans=16384 &>"/dev/null"
    sysctl -w net.ipv4.tcp_orphan_retries=0 &>"/dev/null"

    ## Don't cache ssthresh from previous connection
    ## ---------------------------------------------
    sysctl -w net.ipv4.tcp_no_metrics_save=1 &>"/dev/null"
    sysctl -w net.ipv4.tcp_moderate_rcvbuf=1 &>"/dev/null"

    ## Increase size of RPC datagram queue length
    ## ------------------------------------------
    sysctl -w net.unix.max_dgram_qlen=50 &>"/dev/null"

    ## Don't allow the ARP table to become bigger than this
    ## ----------------------------------------------------
    sysctl -w net.ipv4.neigh.default.gc_thresh3=2048 &>"/dev/null"

    ## Tell the gc when to become aggressive with arp table cleaning
    ## Adjust this based on size of the LAN. 1024 is suitable for most /24 networks
    ## ----------------------------------------------------------------------------
    sysctl -w net.ipv4.neigh.default.gc_thresh2=1024 &>"/dev/null"

    ## Adjust where the GC will leave ARP table alone set to 32
    ## --------------------------------------------------------
    sysctl -w net.ipv4.neigh.default.gc_thresh1=32 &>"/dev/null"

    ## Adjust to ARP table GC to clean-up more often
    ## ---------------------------------------------
    sysctl -w net.ipv4.neigh.default.gc_interval=30 &>"/dev/null"

    ## Increase TCP queue length
    ## -------------------------
    sysctl -w net.ipv4.neigh.default.proxy_qlen=96 &>"/dev/null"
    sysctl -w net.ipv4.neigh.default.unres_qlen=6 &>"/dev/null"

    ## Enable Explicit Congestion Notification
    ## ---------------------------------------
    sysctl -w net.ipv4.tcp_ecn=1 &>"/dev/null"
    sysctl -w net.ipv4.tcp_reordering=3 &>"/dev/null"

    ## How many times to retry killing an alive TCP connection
    ## -------------------------------------------------------
    sysctl -w net.ipv4.tcp_retries2=15 &>"/dev/null"
    sysctl -w net.ipv4.tcp_retries1=3 &>"/dev/null"

    ## Avoid falling back to slow start after a connection goes idle
    ## keeps our cwnd large with the keep alive connections (kernel > 3.6)
    ## -------------------------------------------------------------------
    sysctl -w net.ipv4.tcp_slow_start_after_idle=0 &>"/dev/null"

    ## Allow the TCP fastopen flag to be used
    ## Beware some firewalls do not like TFO (kernel > 3.7)
    ## ----------------------------------------------------
    sysctl -w net.ipv4.tcp_fastopen=3 &>"/dev/null"

    ## This will ensure that immediatly subsequent connections use the new values
    ## --------------------------------------------------------------------------
    sysctl -w net.ipv4.route.flush=1 &>"/dev/null"
    sysctl -w net.ipv6.route.flush=1 &>"/dev/null"

    ## TCP SYN cookie protection
    ## -------------------------
    sysctl -w net.ipv4.tcp_syncookies=1 &>"/dev/null"

    ## TCP RFC 1337
    ## ------------
    sysctl -w net.ipv4.tcp_rfc1337=1 &>"/dev/null"

    ## Reverse path filtering
    ## ----------------------
    sysctl -w net.ipv4.conf.default.rp_filter=1 &>"/dev/null"
    sysctl -w net.ipv4.conf.all.rp_filter=1 &>"/dev/null"

    ## Log martian packets
    ## -------------------
    sysctl -w net.ipv4.conf.default.log_martians=1 &>"/dev/null"
    sysctl -w net.ipv4.conf.all.log_martians=1 &>"/dev/null"

    ## Disable ICMP redirecting
    ## ------------------------
    sysctl -w net.ipv4.conf.all.accept_redirects=0 &>"/dev/null"
    sysctl -w net.ipv4.conf.default.accept_redirects=0 &>"/dev/null"
    sysctl -w net.ipv4.conf.all.secure_redirects=0 &>"/dev/null"
    sysctl -w net.ipv4.conf.default.secure_redirects=0 &>"/dev/null"
    sysctl -w net.ipv6.conf.all.accept_redirects=0 &>"/dev/null"
    sysctl -w net.ipv6.conf.default.accept_redirects=0 &>"/dev/null"
    sysctl -w net.ipv4.conf.all.send_redirects=0 &>"/dev/null"
    sysctl -w net.ipv4.conf.default.send_redirects=0 &>"/dev/null"

    ## Enable Ignoring to ICMP Request
    ## -------------------------------
    sysctl -w net.ipv4.icmp_echo_ignore_all=1 &>"/dev/null"

    ## Disable IPv6
    ## ------------
    sysctl -w net.ipv6.conf.all.disable_ipv6=1 &>"/dev/null"
    sysctl -w net.ipv6.conf.default.disable_ipv6=1 &>"/dev/null"

    loadstatus "[+] Applied Sysctl rules" "OK" "valid"
}

## Service Start
## -------------
function servicestart()
{
    service_uuid=${@}
    if [[ $(systemctl is-active $service_uuid) != "active" ]];
    then
        systemctl start $service_uuid || loadstatus "[*] Unable to start ${service_uuid} service" "!!" "issue"
        loadstatus "[+] Started $service_uuid service" "OK" "valid"
    else
        systemctl reload $service_uuid || loadstatus "[*] Unable to reload ${service_uuid} service" "!!" "issue"
        loadstatus "[+] Reloaded $service_uuid service" "OK" "valid"
    fi

}

## Service Stop
## ------------
function servicestop()
{
    service_uuid=${@}
    if [[ $(systemctl is-active $service_uuid) == "active" ]];
    then
        systemctl stop $service_uuid || loadstatus "[*] Unable to stop ${service_uuid} service" "!!" "issue"
        loadstatus "[+] Stopped $service_uuid service" "OK" "valid"
    fi
}

## Show IP Address
## ---------------
function showipaddr()
{
    sleep 2s
    taddr=$(curl -s https://check.torproject.org/ | cat | grep -m 1 IP | xargs | sed 's/<[^>]*>//g')
    raddr=$(grep -oE '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' <<< "$taddr")
    loadstatus "[+] Remote IP ${raddr}" "OK" "valid"
}

## Switch ID
## ---------
function switchid()
{
    if ! checkstatus;
    then
        loadstatus "[*] TorBridge already stopped" "!!" "issue"
    else
        ## Display IP Address
        ## ------------------
        showipaddr

        ## Stop and Restart Services
        ## -------------------------
        servicestop tor &>"/dev/null"
        sleep 2s
        servicestart tor &>"/dev/null"
        loadstatus "[+] Tor identity switched" "OK" "valid"

        ## Display IP Address
        ## ------------------
        showipaddr
    fi
}

## TorBridge Start
## ---------------
function torstart()
{
    if ! [ -z "$(ls -A $torbridgepath)" ];
    then
        if ! [ -e "$torbridgepath/started" ];
        then
            touch "$torbridgepath/started"
        fi
    fi

    if checkstatus;
    then
        loadstatus "[*] TorBridge already started" "!!" "issue"
    else
        # Display IP Address
        ## ------------------
        showipaddr

        ## Backup Tor Config
        ## -----------------
        backuptorrc

        ## Backup Resolv Config
        ## --------------------
        backupresolv

        ## Backup Iptables Rules
        ## ---------------------
        backupiptables

        ## Backup Sysctl Rules
        ## -------------------
        backupsysctl

        ## Flush Iptables
        ## --------------
        flushiptables

        ## Build Tor Config
        ## ----------------
        configtorrc

        ## Build Rsolv Config
        ## ------------------
        configresolv

        ## Start Services
        ## --------------
        servicestart tor

        ## Apply Rules
        ## -----------
        rulesiptables
        rulessysctl

        ## Display IP Address
        ## ------------------
        showipaddr

        ## Return Notice
        ## -------------
        loadstatus "[+] All traffic is being redirected through Tor" "OK" "valid"
        touch $torbridgepath/started
    fi
}

## TorBridge Status
## ----------------
function torstatus()
{
    service_tor=$(systemctl is-active tor)

    if checkstatus;
    then
        loadstatus "[+] TorBridge is started" "OK" "valid"
    else
        loadstatus "[*] TorBridge is stopped" "!!" "issue"
    fi

    if [[ "${service_tor}" == "active" ]];
    then
        loadstatus "[+] Tor service is ${service_tor}" "OK" "valid"
    else
        loadstatus "[*] Tor service is ${service_tor}" "!!" "issue"
    fi

    ## Display IP Address
    ## ------------------
    showipaddr
}

## TorBridge Stop
## --------------
function torstop()
{
    if ! checkstatus;
    then
        loadstatus "[*] TorBridge already stopped" "!!" "issue"
    else
        ## Restore Sysctl Rules
        ## --------------------
        revertsysctl

        ## Flush Iptables
        ## --------------
        flushiptables

        ## Restore Iptables Rules
        ## ----------------------
        revertiptables

        ## Stop Services
        ## -------------
        servicestop tor

        ## Restore Tor Config
        ## ------------------
        reverttorrc

        ## Restore Resolv Config
        ## ---------------------
        revertresolv

        ## Display IP Address
        ## ------------------
        showipaddr

        ## Return Notice
        ## -------------
        loadstatus "[+] Traffic is not redirected through Tor" "OK" "valid"
        rm -f $torbridgepath/started
    fi
}

## Show Version
## ------------
function version()
{
    echo
    echo -e "[Package]: ${package}"
    echo -e "[Version]: ${version}"
    echo -e "[Website]: ${website}"
}

## Help Menu
## ---------
function helpmenu()
{
    echo 
    echo "Usage: torbridge [-h|--help] [--start] [--stop] [--status] [--restart] [--showip] [--switchid] [--changemac] [--revertmac] [--version]"
    echo
    echo "Options:"
    echo " -h, --help           show this help"
    echo " --start              start redirecting all traffic through Tor"
    echo " --stop               stop redirecting all traffic through Tor"
    echo " --status             check Tor service status"
    echo " --restart            restart Tor and traffic rules"
    echo " --showip             display Tor IP address"
    echo " --switchid           switch Tor identity"
    echo " --changemac          change mac addresses of all interfaces"
    echo " --version            display current version of TorBridge"
}

## Callback
## --------
while test $# -gt 0;
do
    case "$1" in
        -h|--help)
            checkroot
            backupdir
            helpmenu
            exit 1
            ;;
        --start)
            checkroot
            backupdir
            checkinternet
            torstart
            exit 1
            ;;
        --stop)
            checkroot
            backupdir
            torstop
            exit 1
            ;;
        --status)
            checkroot
            backupdir
            torstatus
            exit 1
            ;;
        --restart)
            checkroot
            backupdir
            torstop
            sleep 2s
            torstart
            exit 1
            ;;
        --showip)
            checkroot
            backupdir
            showipaddr
            exit 1
            ;;
        --switchid)
            checkroot
            backupdir
            switchid
            exit 1
            ;;
        --changemac)
            checkroot
            backupdir
            changemac
            exit 1
            ;;
        --revertmac)
            checkroot
            backupdir
            revertmac
            exit 1
            ;;
        --version)
            version
            exit 1
            ;;
        *)
            checkroot
            backupdir
            helpmenu
            exit 1
            ;;
    esac
done

## Check Argument
## --------------
if [ $# -eq 0 ]
then
    checkroot
    backupdir
    helpmenu
fi
